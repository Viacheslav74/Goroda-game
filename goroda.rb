# encoding: UTF-8
=begin
Задача 15-2 
Уверены, вы догадались, для чего было первое задание ;)
Теперь, когда вы умеете доставать из контакта города, ничто не остановит вас от написания собственной программы, которая играет с пользователем в игру «Города». И конечно выигрывает! Ведь городов столько (даже в России), что ни один человек их всех не запомнит.
Итак, используя API ВКонтакте, напишите программу, которая играет с пользователем в «города».

Пример результата:

>ruby main.rb
Играем в города!

Ваш ход!
Москва
Ок, мне на "А"
Агалатово (Ленинградская область, Всеволожский район)

Использованные города
Москва
Агалатово

Ваш ход!
Оренбург
Ок, мне на "Г"
Гаджиево (Мурманская область)

Использованные города
Москва
Агалатово
Оренбург
Гаджиево

Ваш ход!
офигеть...
Со мной эти шуточки не пройдут. Может, пора кончать?
1. Продолжаем
2. Выйти
2
  
=end

# подключаем либы для работы с сетью и XML

require "net/http"
require "uri"
require 'json'

=begin

https://api.vk.com/method/METHOD_NAME?PARAMETERS&access_token=ACCESS_TOKEN&v=V # запрос к API в контакте

https://oauth.vk.com/authorize?client_id=5612783&display=page&redirect_uri=https://oauth.vk.com/blank.html&scope=offline,
messages&response_type=token&v=5.53&state=123456
# открытие диалога авторизации. В окне браузера открыть новую страницу с этим адресом после регистрации нового
приложения на сайте вконтакте.

Открылось новое окно с адресом, где есть access_token:
https://oauth.vk.com/blank.html#access_token=a6b02575a2705dc6e510f3d5a4ca620d546f3f28fc970ad0d4331f46d0285209a881812563c507b853814&expires_in=0&user_id=122516172&state=123456

access_token=a6b02575a2705dc6e510f3d5a4ca620d546f3f28fc970ad0d4331f46d0285209a881812563c507b853814

#https://api.vk.com/method/database.getCities?q=название города&v=5.53 
#database.getCities - метод, но его можно запускать без токена

Создаем головную программу main и класс goroda
=end

class Goroda
   
  def initialize # конструктор - вызывается всегда при создании объекта данного класса
    # Переводим название города в хеш, чтобы одинаково обрабатывать город
    # от пользователя и город из сети
   
    @city = {"title" => "", "area" => "", "region" => ""}

    @last_cities = []  # массив, хранящий хеши уже названных городов
    
    @bad_letters = ["ъ", "ь"] # массив хранящий буквы, с которых города не начинаются
    # спец. поле индикатор состояния игры
    @status = 2 # начало игры
  
  end

   # Метод, который проверяет название города с массивом хешей названных городов
  def test_goroda?
         
     @last_cities.each do |item| # берем каждый хеш массива

        if (item["title"] == @city["title"]) # проверка на 
        # совпадение введенного города от пользователя и города из хэш названных городов 
     
          return true # при совпадении названия города с городом из хеша названных городов
      
        end
     
     end
    
    return false # при не совпадении
  
  end


  # Метод, который берет из названия города последнюю букву
  def last_letter

    last_city = @last_cities.pop # достали хеш последнего названного города из массива
   
    length_city_name = last_city["title"].size - 1 # длина названия города в буквах - 1
    
    town = last_city["title"] # берем название последнего названного города

    end_letter =  town[length_city_name] # последняя буква названия города

    if (end_letter == "ь") || (end_letter == "ъ") # исключительные буквы. На эти буквы нет городов

    length_city_name -= 1

    end_letter =  town[length_city_name] # берем предпоследнюю букву названия города

    end
    
    end_letter = up_letter(end_letter) # делаем последнюю букву заглавной методом up_letter

    @last_cities.push(last_city) # положили обратно в массив хеш последнего названного города
   
    return end_letter # возвращаем последнюю букву города
  end

  # метод, который преобразует строчную букву в заглавную букву
  def up_letter(letter) # в качестве параметра принимается буква
    
    down_letter_alphabit = ["а","б","в","г","д","е","ё","ж","з","и","й","к","л","м","н","о","п","р","с","т","у","ф","х","ц","ч","ш","щ","ъ","ы","ь","э","ю","я"]
    
    up_letter_alphabit = ["А","Б","В","Г","Д","Е","Ё","Ж","З","И","Й","К","Л","М","Н","О","П","Р","С","Т","У","Ф","Х","Ц","Ч","Ш","Щ","Ъ","Ы","Ь","Э","Ю","Я"]
    
    coincidence = false # совпадение букв присвоили ложь 

      for item in down_letter_alphabit do

          if item == letter 
          
          number = down_letter_alphabit.index(item)
          
          coincidence = true # совпадение букв присвоили правда 
               
          end

      end
   
          if coincidence # если есть совпадение букв

          return up_letter_alphabit[number] # возвращаем заглавную букву

          else

          return  letter # возвращаем букву без преобразования

          end 

  end

    # метод, который преобразует заглавную букву в строчную
  def down_letter(letter) # в качестве параметра принимается буква
    
    down_letter_alphabit = ["а","б","в","г","д","е","ё","ж","з","и","й","к","л","м","н","о","п","р","с","т","у","ф","х","ц","ч","ш","щ","ъ","ы","ь","э","ю","я"]
    
    up_letter_alphabit = ["А","Б","В","Г","Д","Е","Ё","Ж","З","И","Й","К","Л","М","Н","О","П","Р","С","Т","У","Ф","Х","Ц","Ч","Ш","Щ","Ъ","Ы","Ь","Э","Ю","Я"]

     coincidence = false # совпадение букв присвоили ложь

      for item in up_letter_alphabit do

          if item == letter 
  
          number = up_letter_alphabit.index(item)

          coincidence = true # совпадение букв присвоили правда 

          end

      end
   
          if coincidence # если есть совпадение букв

          return down_letter_alphabit[number] # возвращаем строчную букву

          else

          return  letter # возвращаем букву без преобразования

          end 
      
  end


 # метод, который преобразует город пользователя в красивый вид: Ижевск 
  def parse_user_city(town) # в качестве параметра принимается название города

      town = town.split("") # массив из букв города. С массивами удобнее работать, у них больше методов. 

      first_letter = town.take(1).join # методом take(1) берем первый элемент массива, методом join
     # преобразовываем массив из одного элемента в строку
      first_letter = up_letter(first_letter) # преобразуем первую букву города в заглавую

      town.delete_at(0) #удаляем первую букву города

      parse_town = [] # массив для преобразованного города

      for item in town do

            parse_town << down_letter(item) # другие буквы города делаем строчными

      end
          
      town_user = parse_town.unshift(first_letter).join # методом unshift добавляем заглавную
      # первую букву города в массив первым элементом. Методом join преобразовываем массив в строку
      return town_user  # возвращаем название города в виде строки

  end

  # метод, который преобразует город пользователя в вид для запроса в сеть. Например, город с дефисом
  # Санкт-Петербург преобразует в Санкт. Город без дефиса преобразует в красивый вид: Ижевск 
  def parse_user_city_for_request(town) # в качестве параметра принимается название города

      town = town.split("") # массив из букв города. С массивами удобнее работать, у них больше методов. 

      item_count = town.length # количество элементов массива из букв города

      first_letter = town.take(1).join # методом take(1) берем первый элемент массива, методом join
     # преобразовываем массив из одного элемента в строку
      first_letter = up_letter(first_letter) # получаем первую букву города заглавной

      town.delete_at(0)    #удаляем первую букву города методом .delete_at(0) 

      parse_town = [] # массив для преобразованного города

      counter = 0 # текущий счетчик цикла

      while counter < item_count  do

        if (town[counter] == "-") || (town[counter] == " ") # проверка на совпадение текущей буквы с тире
        # для городов с тире: Ростов-на-Дону или с пробелом: Набережные Челны 
        
           break # выходим из цикла
        
        end

        parse_town << down_letter(town[counter]) # другие буквы города делаем строчными методом down_letter
        
        counter += 1 # увеличиваем счетчик цикла
      
      end
     
      town_user = parse_town.unshift(first_letter).join # методом unshift добавляем заглавную
      # первую букву города в массив первым элементом. Методом join преобразовываем массив в строку 
            
      return town_user # возвращаем название города в виде строки   

  end

  # Метод преобразовывает хеш с городами из сети в контакте в хеш с городами предназначенными для сравнения.
  # первая буква заглавная, а остальные строчные: Ижевск
  def  parse_cites_hash(cities_hash) # в качестве параметра принимается хеш с городами из сети
    
    cities_hash.each do |key, item| # проходимся по всем элементам хеша с городами из сети в контакте

      item_count = item["count"] #- число найденных совпадений (городов) из запроса в сеть
  
      counter = 0 # счетчик цикла

      parse_hash_cites = [] #хеш преобразованных городов

        while counter < item_count do

        city = item["items"][counter]  #- это массив хешей - первый элемент берем

        city["title"] = parse_user_city(city["title"]) # преобразовали город в вид для сравнения

        parse_hash_cites.push(city) # помещаем в хеш преобразованных городов  
            
        counter += 1
    
        end
    
      return parse_hash_cites # хеш с преобразованными городами

    end

  end


   # Метод, который возвращает хеш с городами из сети в контакте. Параметром является название 
   # города, не хеш с городом
  def http_response(town_request)

    # делаем запрос с названием города town_request в поле q:
    # country_id=1 - это код России, обязательный параметр
    uri = URI::encode("https://api.vk.com/method/database.getCities?country_id=1&q=#{town_request}&need_all=1&count=1000&v=5.53")
   
    uri_p = URI.parse(uri) # парсим запрос
    # Отправляем запрос по адресу uri, методом get с параметром uri и сохраняем результат
    #в переменную json_response. Результат в виде формата JSON согласно API вконтакте
    json_response = Net::HTTP.get(uri_p)

    hash_response = JSON.parse(json_response) # преобразовали и записали данные результата запроса в хэш

    return hash_response
  
  end
  

  # Метод, который возвращает хеш с городами на требуемую букву слова для хода компьютера
  # метод нужен чтобы отсеять города, начинающиеся не с требуемой буквы, из хеша с городами из сети.
  # ответ из сети иногда дает города не с требуемой буквы 
  def last_letter_city(cities_hash) # в качестве параметра принимается хеш с городами из сети
    
    end_letter = last_letter # получаем последнюю букву предыдущего города методом  last_letter

    hash_cities_end_letter = [] # массив для хешей из городов, которые начинаются с требуемой буквы

    cities_hash.each do |key, item| # формируем хеш из городов, которые начинаются с требуемой буквы

      counter = item["count"] #- число найденных совпадений (городов)
    
      while counter > 0 do

        city = item["items"][counter - 1]  #- это массив хешей - первый элемент берем

        if city["title"][0] == end_letter # проверка на совпадение требуемой буквы с первой буквой города из хэш 
        
          hash_cities_end_letter << city # поместили в массив hash_cities_end_letter хеш city
         
        end

        counter -= 1
      
      end

    end
   
    return hash_cities_end_letter # хеш с городами на требуемую букву
  
  end


  # Метод, который возвращает хеш с городом в качестве хода компьютера
  def answer_computer_city(hash_cities_end_letter) # в качестве параметра массив с хешами городов
    
    city_count = hash_cities_end_letter.length # количество элементов массива с хешами городов
    # Он же текущий счетчик цикла
   
    while city_count >= 0 # проходимся по массиву с хешами городов

      @city = hash_cities_end_letter[city_count - 1] # хеш последнего в массиве города
      
      if test_goroda? # проверяем наличие города в массиве названных городов методом test_goroda?
        # true - город уже называли, false - город новый
      else  @last_cities.push(@city) # помещаем в хеш названных городов город-ответ компьютера
         
        return @city # ответ компьютера хеш города

      end
      
      city_count -= 1 # уменьшаем счетчик цикла 
      
    end
      @status = -1 # выйграл пользователь. У компьютера вариант ответа совпадает с названными городами
      
  end


  # Метод, который запрашивает у пользователя город в качестве хода 
  def ask_next_city

      puts "\nВаш ход!"

      city = ""
    
    while city == "" do
    
          city = STDIN.gets.encode("UTF-8").chomp
    end
    
      @city = {"title" => city, "area" => "", "region" => ""}           
  
  end


  # Метод, который проверяет город пользователя, что он начинается
  # с последней буквы предыдущего слова 
  def test_letter_user_city 
   
    end_letter = last_letter # получаем последнюю букву предыдущего города методом  last_letter (заглавная)
     
    if end_letter == up_letter(@city["title"][0]) # проверка на совпадение требуемой буквы с первой буквой города (заглавной)
    # используем метод up_letter    
        return @status = 0 # игра продолжается без ошибок игрока
        
    else  

        return @status = 1 #  игрок ошибся, т.е. город пользователя не начинается
        # с последней буквы предыдущего слова            
    end 
        
  end

  
  # Метод, который проверяет полное совпадение названия города от игрока с городами из сети в контакте
  def city_exist(hash_response)
  
    city_number = -1 # порядковый номер города в массиве городов-хешей.  Когда city_number = -1 значит
    #совпадения городов нет 
    hash_response.each do |item| # определяем есть такой город или нет 
  
      if (@city["title"] == item["title"]) # проверка на совпадение введенного города от 
        #  пользователя и города из хэш 
      city_number = hash_response.index(item) # запоминаем порядковый номер города в массиве городов-хешей
       
      end
    
    end
    
    if city_number == -1  # город не найден

      @status = 1 # игрок ошибся, город не существует
    
    end

    return city_number # возвращает номер города в массиве городов-хешей. Он нужен, чтобы по этому номеру взять
    # правильное название города их хеша-ответа на запрос городов из сети Вконтакте 
  end

  
  # метод для помещения в массив названных городов город пользователя в правильном виде как в сети 
  def push_user_last_city(hash_response, number)
  
      hash_cites = hash_response["response"] # берем хеш с городами
      
      array_cites = hash_cites["items"] # берем массив с хешами городов

      city = array_cites[number]  #- элемент c совпадающим городом берем

      @city["title"] = city["title"] # помещаем в @city правильное название города как в сети

        if test_goroda? # если есть совпадение города с названными городами, то не
        # помещаем в хеш названных городов город-ответ пользователя 
          @status = 1 # игрок ошибся, город повторен
        
        else test_goroda?  
          
          @last_cities.push(city) # помещаем в хеш названных городов город-ответ пользователя 
         
        end

  end


  def status # метод-гетер, возвращает статус игры 
   # @status == -1 выйграл пользователь,
   # @status == 0 пользователь ответил правильно и игра продолжается,
   # @status == 1 пользователь сделал ошибку в ответе, город не с последней буквы предыдущего города или
   #такого города нет или город уже называли
   # @status == 2 начало игры, в массиве названных городов нет ни одного слова
   # @status == 3 после неправильного ответа пользователя ему предоставляется следующий шанс предложить иной вариант ответа 
   # и игра продолжается
    @status
  end


  def user_step # метод, который делает ход игрока
      
      ask_next_city # метод, который спрашивает город у пользователя
      
      if @status != 2 # если не начало игры  
      
        test_letter_user_city # Метод, который проверяет город пользователя, что он начинается
        # с последней буквы предыдущего города 
      end
      
      if @status == 0 || @status == 2 || @status == 3 # игра продолжается или проверка после метода test_letter_user_city

          @city["title"] = parse_user_city(@city["title"]) # метод, который преобразует город пользователя в красивый вид: Ижевск

          city = {"title" => "", "area" => "", "region" => ""} # город для запроса

          city["title"] = parse_user_city_for_request(@city["title"]) # метод, который преобразует город пользователя для запроса

          hash_response = http_response(city["title"]) # Метод, который возвращает хеш с городами из сети в контакте

          cities_hash = parse_cites_hash(hash_response) # преобразовали города в вид для сравнения

          city_number = city_exist(cities_hash) # Метод, который проверяет полное совпадение названия 
          # города от игрока с городами из массива преобразованных городов из сети и выдает поряд. № города в массиве
          # если -1 тогда город не найден        
        if @status != 1 # город найден

          hash_response = http_response(city["title"]) # Метод, который возвращает хеш с городами из сети в контакте 
          # повторно, потому что переменная hash_response меняется после метода parse_cites_hash. Почему непонятно.
          push_user_last_city(hash_response, city_number) # метод помещает в массив названных городов город-ответ пользователя
          # в правильном виде как в сети
          if @status != 1 # город найден

          @status = 0 # игра продолжается без ошибок игрока

          end
                             
        else  
                    
          return # выходим из метода, @status = 1 # игрок ошибся город не правильный
          
        end  
      
      end

  end 

  
  def computer_step # метод, который делает ход компьютера
      
      lastletter = last_letter # получаем последнюю букву предыдущего слова, используем метод last_letter
      puts
      puts "Ок, мне на #{lastletter}"  

      hash_response = http_response(lastletter) # Метод, который возвращает хеш с городами из сети в контакте
      # в качестве параметра используем последнюю букву предыдущего слова 
      hash_cities_end_letter = last_letter_city(hash_response) # Метод, который возвращает хеш с городами на 
      #требуемую букву слова для хода компьютера
      @city = answer_computer_city(hash_cities_end_letter) # Метод, который возвращает хеш с городом в
      # качестве хода компьютера в качестве параметра массив с хешами городов
      if @status == -1 # проверка после метода answer_computer_city. Компьютер проиграл 
     
         return # выходим из метода возвращая пустое значение, @status = -1
      
      end

      puts "#{@city["title"]}".encode("UTF-8")# печатаем город-ответ от компьютера. Принудительная кодировка
      # в UTF-8, чтобы правильно вывести слово  
      puts # пустая строка
          
      puts "Использованные города:\n\n"
          
      @last_cities.each do |item| # берем каждый хеш массива и печатаем название города

          puts "#{item["title"]}\n\n".encode("UTF-8")
     
      end
     
  end 


   # Основной метод игры "сделать следующий шаг"
  def next_step # метод котрый делает ход игорка и компьютера

    if  @status != 2 # если не начало игры

    @status = 3 # игроку предоставляется следующий шанс и игра продолжается

    end

    while @status == 2 || @status == 3 
      
     user_step # метод, который делает ход игрока, если ошибок у игрока нет @status = 0, @status = 3  

        if @status == 1 # # если статус игры равен 1 - игрок ошибся, то предоставляем ему возможность изменить
        # свой ответ  
          user_choice = ""
    
          until (user_choice == "1") || (user_choice == "2") do # берем у пользователя вариант ответа
    
             puts "Со мной эти шуточки не пройдут. Может, пора кончать?\n" + 
                  "1. Продолжаем\n" +
                  "2. Выйти"  

             user_choice = STDIN.gets.encode("UTF-8").chomp
         
          end

          if user_choice == "1" # продолжаем игру

                @status = 3 # игра продолжается по желанию игрока

          elsif user_choice == "2" # выходим из игры по желанию игрока

                return # игра закончена по желанию игрока, выходим из метода возвращая пустое значение, @status = 1

          end 
              
        end

    end

    computer_step # метод, который делает ход компьютера
        
    if @status == -1 # пользователь выйграл 
          
       puts "Вы выйграли. У компьютера больше нет вариантов ответа"
       return # выходим из метода возвращая пустое значение, @status = -1
      
    end

  end

end